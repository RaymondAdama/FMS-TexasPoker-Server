// SSAS file
/*
 * application.onAppStart:
 *     is called when application load. It contains Live (out of the box)
 * application specific initializations.
 */

var pokerTemplates = []; // Store A set of Poker;
var tableList = [];  // list of  Table,include self-define table;
var g_TexasGlobal = {};  //shareobject store global param;
var g_tax = {};
var systemProfit = 0;
var g_tableSOArr = [];
var tableSitPoker = [];
var filterString = ["你妈", "你妈B", "傻逼", "SB", "煞笔", "操", "fuck", "cao", "kao", "共产党", "政府"];
/*Array  to store ShareObject of a table*/

var chargemanList = [];


application.onAppStart = function ()
{
	load("table.asc");
	load("game.asc");
	load("sitClass.asc");
	load("poker.asc");
	load("pokerResult.asc");
	load("usermsgClass.asc");


	application.registerClass("Table", Table);
	application.registerClass("Game", Game);
	application.registerClass("sitClass", sitClass);
	application.registerClass("Poker", Poker);
	application.registerClass("pokerResult", pokerResult);
	application.registerClass("usermsgClass", usermsgClass);

	var poker = {}; // single poker object, property "type"&"number";
	g_tax.mode = 0 //or 1= "dynamic",0为固定抽水，1为税率抽水；
	g_tax.rate = 20; //固定抽水可在计算时进行改变。

	//set Debug Mode
	application.allowDebug = true;
	application.version = "alpha1";
	Client.prototype.name = "";
	Client.prototype.hyuid = "";
	Client.prototype.totalbalance = 0;
	Client.prototype.currentbalance = 0
	Client.prototype.status = "idle"; //"idle"/looking/gaming/prepair
	Client.prototype.roomindex = -1;
	Client.prototype.sitindex = -1;
	Client.prototype.myPoker;
	Client.prototype.clientTotalBet = 0

	g_TexasGlobal = SharedObject.get("TexasGlobal", true);
	g_TableListSO = SharedObject.get("RoomList", true);
	g_TableListSO.clear();

	tableList[2000] = new Table();
	g_tableSOArr[2000] = "";

	if (!g_TexasGlobal.getProperty("gameindex"))
	{
		g_TexasGlobal.setProperty("gameindex", 1000);
	}

	//初始化全局扑克模板。
	//草花
	for (var p = 2; p < 15; p++)
	{
		var poker = new Poker();
		poker.type = "caohua";
		poker.number = p;
		pokerTemplates.push(poker)
	}
	//方片
	for (var k = 2; k < 15; k++)
	{
		var poker = new Poker();
		poker.type = "fangpian";
		poker.number = k;
		pokerTemplates.push(poker)
	}
	//黑桃
	for (var s = 2; s < 15; s++)
	{
		var poker = new Poker();
		poker.type = "heitao";
		poker.number = s;
		pokerTemplates.push(poker)
	}
	//红桃
	for (var r = 2; r < 15; r++)
	{
		var poker = new Poker();
		poker.type = "hongtao";
		poker.number = r;
		pokerTemplates.push(poker)
	}
	//系统盈余
	if (!g_TexasGlobal.getProperty("systemprofit"))
	{
		g_TexasGlobal.setProperty("systemprofit", systemProfit);
		SharedObject.commit("TexasGlobal");
	}
	else
	{
		systemprofit = g_TexasGlobal.getProperty("systemprofit");
	}

	//初始化房间列表,2000以内的ID，为系统固定
	//if (!g_TexasGlobal.getProperty("tableList"))
	//
	for (var w = 1000; w < 1010; w++)
	{
		var table = new Table();

		table.id = w;
		table.name = "初级";
		table.bigBlind = 20;
		table.type = 0;
		table.isLocked = false;
		table.password = "";
		tableList[table.id] = table;
		g_tableSOArr[table.id] = creatTableso(table);
	}
	for (var w = 1300; w < 1350; w++)
	{
		var table = new Table();
		table.id = w;
		table.name = "中级";
		table.bigBlind = 50;
		table.type = 0;
		table.isLocked = false;
		table.password = "";

		tableList[table.id] = table;
		g_tableSOArr[table.id] = creatTableso(table);
	}
	for (var w = 1700; w < 1710; w++)
	{
		var table = new Table();
		table.id = w;
		table.name = "高级";
		table.bigBlind = 100;
		table.type = 0;
		table.isLocked = false;
		table.password = "";

		tableList[table.id] = table;
		g_tableSOArr[table.id] = creatTableso(table);
	}

	/*If transfer to Client ,password should be delete or set to null*/
//	g_TableListSO.setProperty("List", transferTablelist(tableList));
	g_SOWrite(g_TableListSO, "List", transferTablelist(tableList));
	SharedObject.commit("TexasGlobal");
	SharedObject.commit("RoomList");
	// Logging
	trace("Starting  Service...");

}
application.onConnect = function (newClient, username, password)
{
	if (password == "123456")
	{
		var sameuser = false;
		var err = "";
		newClient.name = username;
		for (var index = 0; index < application.clients.length; index++)
		{
			//if the login user is exist
			if (application.clients[index].name == newClient.name)
			{
				sameuser = true;
			}
			// trace ("The UserName  is " + application.clients[index].name);
		}
		if (sameuser)
		{
			err = "You cann't login twice";
			this.rejectConnection(newClient, err)
			return;
		}
		else
		{
			newClient.totalbalance = 50000; //demo
			newClient.currentbalance = 20000;   //demo;
			newClient.status = "idle"; //"idle"/looking/gaming/prepair
			newClient.roomindex = -1;
			newClient.sitindex = -1;

			newClient.writeAccess = "";
			newClient.hyuid = newClient.id;
			newClient.myPoker = null;
			newClient.clientTotalBet = 0;

			this.acceptConnection(newClient);
			newClient.call("loginok", null, newClient);
			trace(newClient.name + "   " + newClient);

		}
	}
	else
	{
		var err = "Incorrect Password";
		this.rejectConnection(newClient, err);
	}
};
// when client disconnect from server. can be improved
application.onDisconnect = function (clientObj)
{
	trace("Client Disconnect :" + clientObj.id + "  " + clientObj.name);

	onUserdisconnect(clientObj);

};
//Get tableList(RoomList)
/**
 *  getRoomList消息，客户端请求房间列表。服务端返回房间列表数组.
 */
Client.prototype.getRoomList = function ()
{
	return tableList;
};
/**
 * getClientlist消息，请求用户列表。返回服务端保存的所有Client对象
 */
Client.prototype.getClientlist = function ()
{
	"use strict";
	return  application.clients;
};

/**
 * getMyself消息，请求自己的对象。返回服务端保存的Client对象
 */
Client.prototype.getMyself = function ()
{
	return this;
}

/**
 * addSOproperty 函数，客户端增加或者设置SO 的属性；
 */
Client.prototype.addSOproperty = function (propName, Value)
{
	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex < 0 || !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}

	writeSOProperty(this.roomindex, propName, Value);
	return this;
}

/**
 * delSOproperty 函数，客户端删除SO 的属性；
 */
Client.prototype.delSOproperty = function (propName)
{
	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex < 0 || !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}
	this.writeAccess = "";
	writeSOProperty(this.roomindex, propName, undefined);
	return this;
}


/**
 * buyChip消息，客户端调用，携带筹码（购买筹码）消息
 */
Client.prototype.buyChip = function (chipnum)
{
	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex != -1 && !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}

	if (this.totalbalance - chipnum < 0)
	{
		return {errid:100, content:"NOT enough balance"};
	}

	trace("PRE-Totalbalance : " + this.totalbalance + "  CurBlan: " + this.currentbalance);
	this.totalbalance = this.totalbalance - chipnum;
	this.currentbalance = this.currentbalance + chipnum;
	trace("AFter-Totalbalance : " + this.totalbalance + "  CurBlan: " + this.currentbalance);
	return {errid:1, content:this};
}

/**
 *  createRoom 函数, 客户端带入的参数为对象，如果有错误，服务端返回Null ，否则，服务端返回Table对象。
 *  并将此对象保存到tableList 数组。 +2000 的作用是 保持自定义桌子的 ID 大于 2000.
 */
Client.prototype.createRoom = function (tableobj)
{
	trace("Creat Room Is Called");
	var selftable = new Table();

	//self-define table name must not be  "初级/中级/高级";
	if (!tableobj.name || tableobj.name == "初级" || tableobj.name == "中级" || tableobj.name == "高级")
	{
		selftable = null;
		return false;
	}
	else
	{
		selftable.name = tableobj.name;
	}
	//one person ,Only can creat one table;
	for (var index in tableList)
	{
		if (index == "print" || index == "getUnique" || index == "getSame")
		{
			continue;
		}
		if (tableList[index].createrName == this.hyuid)
		{
			selftable = null;
			return  false;
		}
	}

	//self-define table,bigblind must greater than 20. smaller than 10000;
	if (!tableobj.bigBlind || tableobj.bigBlind < 21 || tableobj.bigBlind > 10000)
	{
		selftable = null;
		return false;
	}
	else
	{
		selftable.bigBlind = tableobj.bigBlind;
	}

	//if  set room locked, password must  not blank .
	if (tableobj.password == "")
	{
		selftable.isLocked = false;
	}
	else
	{
		selftable.isLocked = true;
		selftable.password = tableobj.password;
	}


	selftable.type = 1;  //force table type be 1
	selftable.createrName = this.hyuid; //Creater Name

	selftable.id = tableList.length + 1;
	tableList[selftable.id] = selftable;
	g_tableSOArr[selftable.id] = creatTableso(selftable);
	trace("is write success?");

	trace("TableList Length :" + tableList.length + "ID IS ：" + selftable.id);

	this.roomindex = selftable.id;
	/*tableList[k] is a Table Object*/
	this.sitindex = 3;
	this.status = "prepair";
	/*Make the player sitdown  at  sit3*/
	var sitobj = new sitClass();
	sitobj.playing = this;
	writeSOProperty(this.roomindex, "sit3", sitobj);
	trace("is write success?");

	/*Delete Password  Prop ,and broadCast to  Client*/
	var addTable = Clone(selftable);
	delObjprop(addTable, null, null);
//	g_TableListSO.setProperty("Creat", {tableIndex:this.roomindex, tableObj:selftable});
	g_SOWrite(g_TableListSO, "Creat", {tableIndex:this.roomindex, tableObj:selftable})
//	SharedObject.commit("RoomList");
	return selftable;
}

/**
 * enterRoom, 假如房间序号为 -1，那就是相当于 leaveRoom。
 * version2 ：本版本开始支持房间密码。
 * 此处的Room 实际上是桌子。
 * @param tableID, Table对象的ID值，整数，允许为负
 * @param password, 房间密码。
 */
Client.prototype.enterRoom = function (tableID, password)
{
	"use strict";
//	trace("enterRoom is called :  " + tableID + "password :  " + password + "table have password ? " + tableList[tableID].password != "");
	if (!tableList[tableID] && tableID != -1)
	{
		return {errID:101, content:"请求的桌子不存在"};
	}
	if (tableList[tableID] && tableList[tableID].isLocked == true)
	{
		if (!password || password != tableList[tableID].password)
		{
			return {errID:103, content:"password incorrect"};
		}
	}

	if ((this.roomindex == -1 && tableID == -1) || this.sitindex > 5 || this.roomindex == tableID)
	{
		return {errID:102, content:"what r u doing?"};
	}

	if (this.status == "gaming") //用户正在游戏中;
	{
		return {errID:100, content:"你正在游戏中"};
	}


	var preTableindex = 0;
	var srcArr = [];
	var dstArr = [];
	var sitprop = "";
	var sitobj = {};

	if (tableID == -1)
	{
		/*if tableid is -1,the user infact request leaving room*/
		preTableindex = this.roomindex;
		this.roomindex = tableID;
		if (this.sitindex < 0)
		{
			/*user in a room and looking*/

			srcArr = readSOProperty(preTableindex, "visitor");
			for (var x = 0; x < srcArr.length; x++)
			{
				if (srcArr[x] && srcArr[x].id == this.id)
				{
					srcArr.splice(x, 1);
					break;
				}
			}
			this.status = "idle";
			writeSOProperty(preTableindex, "vistitor", srcArr);
			return {errID:1, content:this}
		}
		else
		{
			/*user in a room and sitdown*/
			sitprop = "sit" + this.sitindex;
			sitobj = readSOProperty(preTableindex, sitprop);
			if (sitobj.playing && sitobj.playing.id == this.id)
			{
				sitobj.playing = null;
				this.status = "idle";
			}
			if (sitobj.waiting && sitobj.waiting.id == this.id)
			{
				sitobj.waiting = null;
				this.status = "idle";
			}
			this.sitindex = -1;
			writeSOProperty(preTableindex, sitprop, sitobj);
			return {errID:1, content:this}
		}

	}
	else
	{
		/*if tableid is not -1,the user infact request Change room*/
		preTableindex = this.roomindex;
		this.roomindex = tableID;
		if (this.sitindex < 0)
		{
			/*user in a room and looking*/
			// remove user from current table & vistor list,ONLY FOR USER HAVE ROOM NOW
			if (preTableindex != -1)
			{
				srcArr = readSOProperty(preTableindex, "visitor");
				for (var x = 0; x < srcArr.length; x++)
				{
					if (srcArr[x] && srcArr[x].id == this.id)
					{
						srcArr.splice(x, 1);
						break;
					}
				}
				this.status = "idle";
				writeSOProperty(preTableindex, "vistitor", srcArr);
			}
			//add user to destionation table ,as a visitor
			dstArr = readSOProperty(this.roomindex, "visitor");
			dstArr.push(this);
			writeSOProperty(this.roomindex, "visitor", dstArr);
			return {errID:1, content:this}
		}
		else
		{
			/*user in a room and sitdown*/
			// remove user from current table & current Sit;
			sitprop = "sit" + this.sitindex;
			sitobj = readSOProperty(preTableindex, sitprop);
			if (sitobj.playing && sitobj.playing.id == this.id)
			{
				sitobj.playing = null;
				this.status = "idle";
			}
			if (sitobj.waiting && sitobj.waiting.id == this.id)
			{
				sitobj.waiting = null;
				this.status = "idle";
			}
			this.sitindex = -1;
			writeSOProperty(preTableindex, sitprop, sitobj);
			//add user to destionation table ,as a visitor
			dstArr = readSOProperty(this.roomindex, "visitor");
			dstArr.push(this);
			writeSOProperty(this.roomindex, "visitor", dstArr);

			return {errID:1, content:this}
		}
	}
	return {errID:999, content:"unknow error"};
}

/**
 *  sitDown 消息。客户端在进入房间后，需要坐下的时候使用。
 *  version2：增加了客户端的当前携带的检查。如果携带值小于大盲注，不允许坐下。
 */
Client.prototype.sitDown = function (index)
{
	trace("sitDown is calling")

	if (index == this.sitindex)
	{
		return {errID:103, content:"you are alreay sit down"};
	}

	if (this.status == "gaming") //用户正在游戏中;
	{
		return {errID:104, content:"you are in game now"};
	}

	if (index > 5 || index < 0)
	{
		return {errID:105, content:" there's no sit "};
	}

	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex != -1 && !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}
	if (this.currentbalance < tableList[this.roomindex].bigBlind)
	{
		return {errID:106, content:"you have no enough balance to play"};
	}

	var preSitindex = this.sitindex;
	var preSitClass = {};
	var dstSitClass = readSOProperty(this.roomindex, "sit" + index);
	var tableStatus = readSOProperty(this.roomindex, "tableStatus");

	if (dstSitClass.playing || dstSitClass.waiting)
	{
		return {errID:100, content:"there's other one in that sit"};
	}


	if (this.sitindex < 0)
	{
		/*The user is a visitor of this table, preSitClass is an array*/
		preSitClass = readSOProperty(this.roomindex, "visitor");
		var k = preSitClass.indexOf(this);
		if (k != -1)
		{
			preSitClass.splice(k, 1);
		}
		writeSOProperty(this.roomindex, "visitor", preSitClass);
	}
	else
	{
		/*the user is sit in other sit,just change sit*/

		preSitClass = readSOProperty(this.roomindex, "sit" + this.sitindex);
		preSitClass.playing = null;
		preSitClass.waiting = null;
		writeSOProperty(this.roomindex, "sit" + preSitindex, preSitClass);
	}

	/*if this table is not in gaming,put user to playing,else ,put user to waiting*/
	this.sitindex = index;
	this.status = "prepair"
	dstSitClass = readSOProperty(this.roomindex, "sit" + index);
	if (tableStatus < 2)
	{
		dstSitClass.playing = this;
		this.sitindex = index;
	}
	else
	{
		dstSitClass.waiting = this;
		this.sitindex = index;
	}
	writeSOProperty(this.roomindex, "sit" + index, dstSitClass);

	if (tableStatus % 3 == 0)
	{
		this.prepairGame(this.roomindex);
	}
	trace("sitDown is finished calling");
	return {errID:1, content:this};
}

/**
 *  standUp 消息。客户端在进入房间后，需要坐下的时候使用。
 */
Client.prototype.standUp = function ()
{
	if (this.sitindex < 0 || this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:100, content:"your sitIndex is wrong or not sitDown"};
	}
	var tablestatus = readSOProperty(this.roomindex, "tableStatus");
	if (tablestatus == 2)
	{
		return {errID:101, content:"you cannot standUp when game is not finished"};
	}

	/*first delete user from current sit*/
	var preSitClass = readSOProperty(this.roomindex, "sit" + this.sitindex);
	preSitClass.playing ? preSitClass.playing = null : 1 == 1;
	preSitClass.waiting ? preSitClass.waiting = null : 1 == 1;
	writeSOProperty(this.roomindex, "sit" + this.sitindex, preSitClass);

	/*put the user to visitor list*/
	var visitorArr = readSOProperty(this.roomindex, "visitor");
	visitorArr.push(this);
	writeSOProperty(this.roomindex, "visitor", visitorArr);
	/*set the sitindex to  -1,that means the user have no sit*/
	this.sitindex = -1;
	this.status = "looking";
	return {errID:1, content:this};
}

/**
 *  prepairGame 消息。客户端在进入房间后，需要坐下的时候使用。
 */
Client.prototype.prepairGame = function (tableID)
{
	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex < 0 || this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex < 0 || !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}

	var tableStatus = readSOProperty(this.roomindex, "tableStatus");
	var timeStamp = readSOProperty(this.roomindex, "gameStarttime")
	var tempsitClass;
	if (!checkSmallestsit(this))
	{
		return {errID:105, content:"you cannot prepair Game"};
	}

	var prepNum = 0;
	for (var p = 0; p < 6; p++)
	{
		tempsitClass = readSOProperty(this.roomindex, "sit" + p);
		if (tempsitClass.playing)
		{
			prepNum++;
		}

	}

	trace("prepNum is :" + prepNum + "   ,and tableStatus is :" + tableStatus);
	if (tableStatus % 3 < 1 && prepNum > 1)
	{
		timeStamp = getTime();
		writeSOProperty(this.roomindex, "gameStarttime", timeStamp);
		writeSOProperty(this.roomindex, "tableStatus", 1);
		return true;
	}

	if (prepNum < 2 || tableStatus % 3 > 1)
	{
		return false;
	}
	return false;
}

/**
 *  letmePlay 消息，客户端调用，用于用户在等待上一局结束后调用。将用户从等待队列转向参与游戏
 */
Client.prototype.letmePlay = function ()
{
	"use strict";
	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex < 0 || this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex < 0 || !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}
	if (this.currentbalance < 1)
	{
		return {errID:103, content:"you have no enough balance to play"};
	}


	var sitobj = readSOProperty(this.roomindex, "sit" + this.sitindex);
	var tableStatus = readSOProperty(this.roomindex, "tableStatus");
	if (tableStatus == 2)
	{
		return {errID:102, content:"Game is already starting"};
	}
	if (sitobj.playing && sitobj.playing.id == this.id)
	{
		return {errID:100, content:"you have already for play"};
	}
	if (sitobj.waiting && sitobj.waiting.id != this.id)
	{
		return {errID:101, content:"you are not in this sit"};
	}
	if (!sitobj.playing && sitobj.waiting.id == this.id)
	{
		sitobj.waiting = null;
		sitobj.playing = this;
		writeSOProperty(this.roomindex, "sit" + this.sitindex, sitobj);
		this.prepairGame(this.roomindex);
		return {errID:1, content:"you are ready for playing"};
	}
	return {errID:999, content:"unexpected error"};
}

/**
 * startGame消息。在游戏进入预准备阶段后被调用。代表游戏真正开始。初始化游戏中的牌。
 */
Client.prototype.startGame = function ()
{
	"use strict";
	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex < 0 || this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex < 0 || !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}


	var gameStarttime = readSOProperty(this.roomindex, "gameStarttime");
	var tableStatus = readSOProperty(this.roomindex, "tableStatus");
	var tableUsers = readSOProperty(this.roomindex, "tableUsers");
	var sitobj = new sitClass();
	if (!checkSmallestsit(this))
	{
		return {errID:105, content:"you cannot start Game"};
	}

	if (getTime() - gameStarttime < 5000)
	{
		return {errID:100, content:"we are still waiting for user join" + (getTime() - gameStarttime)};
	}
	if (tableStatus > 1)
	{
		return {errID:103, content:"Game Already start"};
	}
	tableUsers = 0;

	for (var k = 0; k < 6; k++)
	{
		sitobj = readSOProperty(this.roomindex, "sit" + k);
		if (sitobj.playing)
		{
			if (isAlive(sitobj.playing.id))
			{
				tableUsers++;
				sitobj.refresh();
				writeSOProperty(this.roomindex, "sit" + k, sitobj);
			}
			else
			{
				sitobj.playing = null;
				writeSOProperty(this.roomindex, "sit" + k, sitobj);
			}

		}
	}

	if (tableUsers < 2)
	{

		return {errID:103, content:"there's not enough people"};
	}
	else
	{
		writeSOProperty(this.roomindex, "tableUsers", tableUsers)
	}
	/*we can delete pre-sessionID now .because the game will really start*/
	delete chargemanList[this.roomindex];

	/*check every sit ,make sure everything is ready*/
	for (var k = 0; k < 6; k++)
	{
		sitobj = readSOProperty(this.roomindex, "sit" + k);

		if (sitobj.playing && isAlive(sitobj.playing.id))
		{
			if (!chargemanList[this.roomindex])
			{
				chargemanList[this.roomindex] = randRange(1000000, 9999999);
				trace("chargemanlist [this.roomindex] is :" + chargemanList[this.roomindex]);
				var clientobj = getClient(sitobj.playing.id);
				clientobj ? clientobj.call("getsessionid", null, chargemanList[this.roomindex]) : 1 == 1;
			}
		}
		writeSOProperty(this.roomindex, "sit" + k, sitobj)
	}
	/*set table status to 2 = in gaming*/
	writeSOProperty(this.roomindex, "tableStatus", 2);
	/*Change Round to 0*/
	writeSOProperty(this.roomindex, "roundStatus", 0);
	return {errID:1, content:"Game start Successful"};
}

/**
 * xiaZu消息。玩家进行下注，不区分跟牌等类型，只判断是否能下注，如果是过牌，参数为0。
 */
Client.prototype.xiaZu = function (betNum, betType)
{
	"use strict";

	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex < 0 || this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex < 0 || !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}

	var sitobj = readSOProperty(this.roomindex, "sit" + this.sitindex);
	var roundStatus = readSOProperty(this.roomindex, "roundStatus")
	var tabletotalBet = readSOProperty(this.roomindex, "tableTotalbet");

	if (sitobj.giveup > -1)
	{   /*user gived up,gamestatus indicate which round he give up */
		return {errID:103, content:"your have already give up"};
	}

	if (!sitobj.playing || sitobj.playing.id != this.id)
	{
		return {errID:104, content:"you are not the right person"};
	}
	if (this.currentbalance - betNum < 0 || (betNum != 0 && betNum * 2 < tableList[this.roomindex].bigBlind))
	{
		trace("roomindex: " + this.roomindex + "  bigblind: " + tableList[this.roomindex].bigBlind + " curblan: " + this.currentbalance + "  betNum: " + betNum);
		return {errID:105, content:"your currentBalance not enough,pls buyChip first"};
	}
	else
	{
		this.currentbalance = this.currentbalance - betNum;
	}
	sitobj.betrecord[roundStatus] = sitobj.betrecord[roundStatus] + betNum;
	sitobj.sitTotalbet += betNum;
	sitobj.playing = this;
	tabletotalBet += betNum;
	trace (" SIT "+this.sitindex + " sittotalBET is : "+sitobj.sitTotalbet)
	writeSOProperty(this.roomindex, "tableTotalbet", tabletotalBet);
	writeSOProperty(this.roomindex, "sit" + this.sitindex, sitobj);
	return  {errID:1, content:this};
}

/**
 * giveUp消息。玩家盖牌时调用。
 */
Client.prototype.giveUp = function ()
{
	"use strict";

	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex < 0 || this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex < 0 || !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}

	var sitobj = readSOProperty(this.roomindex, "sit" + this.sitindex);
	var roundStatus = readSOProperty(this.roomindex, "roundStatus");
	var tablestatus = readSOProperty(this.roomindex, "tableStatus");

	if (tablestatus != 2)
	{
		return {errID:104, content:"Game is not start yet,Qing"};
	}
	if (sitobj.giveup > -1)
	{
		/*user gived up,gamestatus indicate which round he give up */
		return {errID:103, content:"your have already give up"};
	}

	if (!sitobj.playing || sitobj.playing.id != this.id)
	{
		return {errID:104, content:"you are not the right person"};
	}
	if (sitobj.playing && sitobj.playing.id == this.id)
	{
		sitobj.giveup = roundStatus;
		writeSOProperty(this.roomindex, "sit" + this.sitindex, sitobj);
	}
	return {errID:1, content:"give up OK"};
}

/**
 * changeRound消息。由座位号最小的玩家负责调用，引导牌局进行。
 */
Client.prototype.changeRound = function (roundNum, key)
{
	"use strict";

	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex < 0 || this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex < 0 || !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}
	if (chargemanList[this.roomindex] != key)
	{
		return {errID:103, content:"you are not the right person"};
	}
	if (roundNum < 0 || roundNum > 3)
	{
		return {errID:105, content:"your roundNumber is wrong"};
	}

	var tablestatus = readSOProperty(this.roomindex, "tableStatus");
	var roundStatus = readSOProperty(this.roomindex, "roundStatus");
	var sitobj = readSOProperty(this.roomindex, "sit" + this.sitindex);
//	var pokerTemplate = readSOProperty(this.roomindex, "pokerTemplate");
	var pokerTemplate = tableList[this.roomindex].pokerTemplate;
	var publicPoker = readSOProperty(this.roomindex, "publicPoker");

	if (!sitobj.playing || sitobj.playing.id != this.id)
	{
		return {errID:104, content:"you are not the right person"};
	}
////---------for debug only---------
//	var pokera=new Poker();
//	pokera.type = "heitao";pokera.number = 4;
//	var pokerb = new Poker();
//	pokerb.type = "caohua";pokerb.number =5;
//	var pokerc = new Poker();
//	pokerc.type = "fangpian";pokerc.number =6;
//	var pokerd = new Poker();
//	pokerd.type = "hongtao";pokerd.number =7;
//	var pokere = new Poker();
//	pokere.type = "caohua";pokere.number =8;
//
//	var customArr = [];
//	customArr.push(pokera);
//	customArr.push(pokerb);
//	customArr.push(pokerc);
//	customArr.push(pokerd);
//	customArr.push(pokere);
////---------for debug only---------


	if (chargemanList[this.roomindex] == key && sitobj.playing.id == this.id)
	{
		var max = pokerTemplate.length - 1;
		var randomnum = 0;
		/*change round is permit*/
		if (roundNum == 1)
		{
			publicPoker = [];
			/*发3张公共牌*/
			for (var p = 0; p < 3; p++)
			{
//				 publicPoker.push(customArr[p]);
				publicPoker.push(pokerTemplate.pop());
			}
//			writeSOProperty(this.roomindex, "pokerTemplate", pokerTemplate);
			writeSOProperty(this.roomindex, "publicPoker", publicPoker);
			writeSOProperty(this.roomindex, "roundStatus", roundNum);
			return {errID:1, content:"change Round OK"}

		}
		if (roundNum == 2)
		{
			/*发第四张公共牌*/
//			publicPoker.push(customArr[3]);
			publicPoker.push(pokerTemplate.pop());
//			writeSOProperty(this.roomindex, "pokerTemplate", pokerTemplate);
			writeSOProperty(this.roomindex, "publicPoker", publicPoker);
			writeSOProperty(this.roomindex, "roundStatus", roundNum);
			return {errID:1, content:"change Round OK"}
		}
		if (roundNum == 3)
		{
			/*发第五张公共牌*/
//			publicPoker.push(customArr[4]);
			publicPoker.push(pokerTemplate.pop());
//			writeSOProperty(this.roomindex, "pokerTemplate", pokerTemplate);
			writeSOProperty(this.roomindex, "publicPoker", publicPoker);
			writeSOProperty(this.roomindex, "roundStatus", roundNum);
			return {errID:1, content:"change Round OK"}
		}


	}
	return {errID:999, content:"program error"};
}

/**
 * getMypoker 消息，客户端调用，获取自己的牌
 */
Client.prototype.getMypoker = function ()
{
	"use strict";

	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex < 0 || this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex < 0 || !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}

	var tablestatus = readSOProperty(this.roomindex, "tableStatus");
	var roundStatus = readSOProperty(this.roomindex, "roundStatus");
	var sitobj = readSOProperty(this.roomindex, "sit" + this.sitindex);
	var pokerTemplate = tableList[this.roomindex].pokerTemplate;

	if (tablestatus != 2 || roundStatus > 0)
	{
		return {errID:103, content:"your tableIndex is wrong"};
	}
	if (sitobj.playing && sitobj.playing.id != this.id)
	{
		return {errID:104, content:"you are not the right person"};
	}
	var randomnum = 0;
	var temparr = [];

	for (var k = 0; k < 2; k++)
	{
		temparr.push(pokerTemplate.pop());
	}
	this.myPoker = [];
	this.myPoker = Clone(temparr);
	if (tableSitPoker[this.roomindex])
	{
		tableSitPoker[this.roomindex]["sit" + this.sitindex] = Clone(temparr);
	}
	else
	{
		tableSitPoker[this.roomindex] = {};
		tableSitPoker[this.roomindex]["sit" + this.sitindex] = Clone(temparr);
	}
	temparr = null;
//	writeSOProperty(this.roomindex, "pokerTemplate", pokerTemplate);
	return {errID:1, content:this.myPoker};
}

/**
 * sendMsg消息。玩家说话的时候调用。
 */
Client.prototype.sendMsg = function (message)
{
	"use strict";
	if (this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex < 0 || !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}
	var msg = new usermsgClass();
	msg.userID = this.id;
	msg.userName = this.name;
	msg.content = message;

	writeSOProperty(this.roomindex, "userMessage", msg);

}

/**
 * gameOver 消息，游戏结束时调用
 */
Client.prototype.gameOver = function (key)
{
	"use strict";
	//Todo
	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex < 0 || this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}
	if (this.roomindex < 0 || !tableList[this.roomindex])
	{
		this.roomindex = -1;
		return {errID:102, content:"your tableIndex is wrong,we have reset it"};
	}
	if (chargemanList[this.roomindex] != key)
	{
		return {errID:103, content:"you are not the right person"};
	}
	trace("gameOver called");

	var publicPoker = readSOProperty(this.roomindex, "publicPoker");
	var tabletotalBet = readSOProperty(this.roomindex, "tableTotalbet");
	var tableUsers = readSOProperty(this.roomindex, "tableUsers");
	var alluser = []; //这个是全部的游戏参与者；
	var sitResult = [];

	var validUser = 0;

	/*start collect valid user's poker ,and got the PokerType*/
	for (var k = 0; k < 6; k++)
	{
		var sitobj = new sitClass();
		sitobj = readSOProperty(this.roomindex, "sit" + k);
		alluser[k] = sitobj;
		if (sitobj.sitTotalbet > 0)
		{
			alluser[k].poker1 = tableSitPoker[this.roomindex]["sit" + k][0];
			alluser[k].poker2 = tableSitPoker[this.roomindex]["sit" + k][1];
			if (sitobj.playing && sitobj.giveup < 0)
			{
				if (publicPoker.length > 4)
				{
					/*here is the sitClass object that can earn the money*/
					validUser++;
					var clientOBJ = {};
					clientOBJ = getClient(sitobj.playing.id);
					sitobj.playing = clientOBJ;
					trace("client " + k + " :" + sitobj.playing.id + "/" + clientOBJ.id + " poker :" + clientOBJ.myPoker[0].type + clientOBJ.myPoker[0].number + "  " + clientOBJ.myPoker[1].type + clientOBJ.myPoker[1].number);
					sitobj.pokerResult = this.checkPokertype(publicPoker, tableSitPoker[this.roomindex]["sit" + k]);
					sitobj.poker1 = tableSitPoker[this.roomindex]["sit" + k][0];
					sitobj.poker2 = tableSitPoker[this.roomindex]["sit" + k][1];

					/*add an dynamic  prop to sitobj*/
					sitobj.sitNo = k;
					sitResult.push(sitobj);
					/*update the  sitobj  object*/
					alluser[k] = sitobj;
					clientOBJ = null;
				}
				else
				{
					/*here is the sitClass object that can earn the money*/
					validUser++;
					sitobj.playing = getClient(sitobj.playing.id);
					var notnormalpokerResult = new pokerResult();
					notnormalpokerResult.main = [];
					notnormalpokerResult.pokerScore = 1000000000;
					notnormalpokerResult.pokerType = 10;
					sitobj.pokerResult = notnormalpokerResult;
					sitobj.poker1 = tableSitPoker[this.roomindex]["sit" + k][0];
					sitobj.poker2 = tableSitPoker[this.roomindex]["sit" + k][1];

					/*add an dynamic  prop to sitobj*/
					sitobj.sitNo = k;
					sitResult.push(sitobj);
					/*update the  sitobj  object*/
					alluser[k] = sitobj;
					trace("sitobj content is :" + sitResult[0].pokerResult.pokerType + "/" + sitResult[0].pokerResult.pokerScore);
				}


			}

		}

	}
//	//--------------debug use-----------
//	for (var p =0 ; p < 6; p++)
//	{
//		if (alluser[p])
//		{
//			writeSOProperty(this.roomindex,"sit"+p,alluser[p]);
//		}
//	}
//	//-----------debug finished---------
	trace("validuser : " + validUser + " alluser length : " + alluser.length + " sitResult length: " + sitResult.length);
	if (validUser == 0)
	{
		/*maybe system have error ,but we got all of this bet*/
		systemProfit += tabletotalBet;
		this.resetTable("d96ba302e0c223805ddd2d2f2d45c714");
	}
	if (validUser == 1)
	{

		var sitindex = sitResult[0].sitNo;

		sitobj = readSOProperty(this.roomindex, "sit" + sitindex);
		sitobj.playing = getClient(sitobj.playing.id);
		sitobj.winscore = tabletotalBet;
		sitobj.playing.currentbalance = sitobj.playing.currentbalance + tabletotalBet - g_tax.rate;
		sitobj.pokerResult = sitResult[0].pokerResult;
		sitobj.pokerResult.pokerScore = 1000000000;
		sitobj.pokerResult.pokerType = 10;

		sitobj.sitTotalbet = 0;
		tabletotalBet = 0;
		for (var p = 0; p < alluser.length; p++)
		{
			if (alluser[p] && alluser[p].playing && alluser[p].playing != null && alluser[p].playing.id != sitobj.playing.id)
			{
				alluser[p].winscore = alluser[p].winscore - alluser[p].sitTotalbet;
				alluser[p].sitTotalbet = 0;
				alluser[p].playing = getClient(alluser[p].playing.id);
				writeSOProperty(this.roomindex, "sit" + p, alluser[p]);
				trace ("Sit "+p+" Give UP winSCore IS:" + alluser[p].winscore);
			}
		}

		writeSOProperty(this.roomindex, "sit" + sitindex, sitobj);
		writeSOProperty(this.roomindex, "tableStatus", 3);
		trace ("Sit "+sitindex+"  winSCore IS:" + sitobj.winscore) ;
		return;

	}
	else
	{
		sitResult.sort(ASCsortByScoreAndsitTotalbet);
		trace("sitReust Array  " + "last : " + sitResult[sitResult.length - 1].pokerResult.pokerScore + "   " + sitResult[sitResult.length - 2].pokerResult.pokerScore)
		var comparescore = -1;
		var obj = {};
		var len = sitResult.length;
		var alluserlen = alluser.length;
		var currentDealscore = 0;
		var currentDealBet = 0;
		var tableUsers = readSOProperty(this.roomindex, "tableUsers")
		for (var p = 0; p < validUser; p++)
		{
			/*we shoud check if there's money for us*/
			if (sitResult.length > 0)
			{
				var winpeop = 1;
				var validBet = 0;
				obj = sitResult.pop();

				if (obj.sitTotalbet < 1)
				{
					continue;
				}
				currentDealscore = obj.pokerResult.pokerScore;
				currentDealBet =  obj.sitTotalbet;
				/*then we take it out from  sitResult array*/
				for (var index in sitResult)
				{
					if (index == "print" || index == "getUnique" || index == "getSame")
					{
						continue;
					}

					if (sitResult[index].pokerResult.pokerScore == obj.pokerResult.pokerScore)
					{
						winpeop++;
						/*now we got how many people will share the money,and delete it from alluser array*/
					}
				}

				/*now ,the alluser array is full of loser, obj is means winner with less bet*/

				for (var peop = 0; peop < 6; peop++)
				{
					if (alluser[peop])
					{
						if (alluser[peop].sitTotalbet <currentDealBet)
						{
							validBet = validBet + alluser[peop].sitTotalbet;
							trace (" all user "+peop+" sitTotalBet is : "+alluser[peop].sitTotalbet + " NOW ValidBET IS : "+ validBet)
						}
						else
						{
							validBet = validBet + obj.sitTotalbet;
							trace (" all user "+peop+" sitTotalBet is : "+alluser[peop].sitTotalbet + " NOW ValidBET IS : "+ validBet)
						}
					}

				}
				tabletotalBet = tabletotalBet - validBet;
				var curWinbet = Math.floor(validBet / winpeop);

				trace("TableTotal BET NOW LEFT :  " + tabletotalBet + "   Valid Bet IS :" + validBet + "Win PeopLE is : "+ winpeop + "  curWinBET is : "+curWinbet);

//				for (var x = 0 ; x < sitResult.length;x++)
//				{
//					sitResult[x].sitTotalbet = sitResult[x].sitTotalbet - currentDealBet;
//				}



				for (var index in alluser)
				{
					if (index == "print" || index == "getUnique" || index == "getSame")
					{
						continue;
					}
					if (alluser[index] )
					{
						if (alluser[index].pokerResult.pokerScore < currentDealscore)
						{
							/*Here is the loser*/
							if (alluser[index].sitTotalbet <= currentDealBet)
							{
								alluser[index].winscore = alluser[index].winscore - alluser[index].sitTotalbet;
								alluser[index].sitTotalbet = 0;
								alluser[index].playing ? alluser[index].playing = getClient(alluser[index].playing.id):alluser[index].playing = null;
								if (alluser[index].playing)
								{
									if (alluser[index].playing.currentbalance < (tableList[this.roomindex].bigBlind / 2))
									{
										alluser[index].waiting = alluser[index].playing;
										alluser[index].playing = null;
									}
								}
								else
								{
									alluser[index].playing = null;
								}

								writeSOProperty(this.roomindex, "sit" + index, alluser[index]);
								trace("write : sit" + index + "  " + alluser[index].winscore);//+ alluser[index].playing.id)
							}
							else
							{
								alluser[index].winscore = alluser[index].winscore - currentDealBet;
								alluser[index].sitTotalbet = alluser[index].sitTotalbet - currentDealBet;

							}
						}
						if (alluser[index].pokerResult.pokerScore == currentDealscore)
						{
							/*Here is the winner*/
							alluser[index].sitTotalbet = alluser[index].sitTotalbet - currentDealBet;
							alluser[index].winscore = alluser[index].winscore + curWinbet;

							if (tabletotalBet > 0)
							{

								alluser[index].playing ? alluser[index].playing.currentbalance = alluser[index].playing.currentbalance + curWinbet : alluser[index].playing = null;
								if (alluser[index].sitTotalbet < 1)
								{
									var strSIT = "sit" + index;
									delete alluser[index].sitNo;
									alluser[index].playing ? alluser[index].playing.currentbalance = alluser[index].playing.currentbalance - g_tax.rate : alluser[index].playing = null;
									writeSOProperty(this.roomindex, strSIT, alluser[index]);
									trace("write : " + strSIT + "  " + alluser[index].winscore);//+ obj.playing.id)
								}
							}
							else
							{
								alluser[index].playing ? alluser[index].playing.currentbalance = ( alluser[index].playing.currentbalance + curWinbet - g_tax.rate) : alluser[index].playing = null;
								var strSIT = "sit" + index;
								delete alluser[index].sitNo;
								writeSOProperty(this.roomindex, strSIT, alluser[index]);
								trace("write : " + strSIT + "  " + alluser[index].winscore);
							}

						}

					}

				}



			}
			else
			{
				/*all people have been calc money */
				break;
			}

		}

	}
	writeSOProperty(this.roomindex, "tableStatus", 3);
//	this.cleanPerround(this.roomindex);

}
/**
 *  resetTable 消息，客户端在游戏结束后调用或者，认为需要的时候 调用
 */
Client.prototype.resetTable = function (key)
{
	"use strict";
	if (key != "d96ba302e0c223805ddd2d2f2d45c714")
	{
		return {errID:103, content:"MD5 Password not correct"};
	}
	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}


	var sitobj = new sitClass();

	writeSOProperty(this.roomindex, "tableStatus", 0);
//	writeSOProperty(this.roomindex, "pokerTemplate", washPoker());
	tableList[this.roomindex].pokerTemplate = washPoker();
	writeSOProperty(this.roomindex, "gameStarttime", -1);
	writeSOProperty(this.roomindex, "publicPoker", []);
	writeSOProperty(this.roomindex, "roundStatus", -1);
	writeSOProperty(this.roomindex, "tableTotalbet", 0);
	writeSOProperty(this.roomindex, "tableUsers", 0);
	writeSOProperty(this.roomindex, "visitor", []);

	for (var k = 0; k < 6; k++)
	{
		sitobj = readSOProperty(this.roomindex, "sit" + k)
		if (sitobj.playing)
		{
			!isAlive(sitobj.playing.id) ? sitobj.playing = null : 1 == 1;
			sitobj.refresh();
			writeSOProperty(this.roomindex, "sit" + k, sitobj);
			continue;
		}
		if (sitobj.waiting)
		{
			!isAlive(sitobj.waiting.id) ? sitobj.waiting = null : 1 == 1;
			sitobj.refresh();
			writeSOProperty(this.roomindex, "sit" + k, sitobj);
			continue;
		}
		sitobj.refresh();
		writeSOProperty(this.roomindex, "sit" + k, sitobj);
	}
	return {errID:1, content:this.roomindex};
}


/**
 * onUserdisconnect 函数，在客户端断线的时候调用；
 */
function onUserdisconnect(clientOBJ)
{
	"use strict";
	/*if really disconnect*/

	if (clientOBJ.ping())
	{
		return false;
	}
	/*First we should roll back the chip to user balance */
	trace("user: " + clientOBJ.name + " pre-total = " + clientOBJ.totalbalance + "   pre-current = " + clientOBJ.currentbalance);
	clientOBJ.totalbalance = clientOBJ.totalbalance + clientOBJ.currentbalance;
	clientOBJ.currentbalance = 0;
	trace("user: " + clientOBJ.name + " aft-total = " + clientOBJ.totalbalance + "   aft-current = " + clientOBJ.currentbalance);

	/*if data is illegal*/
	if (clientOBJ.roomindex < 0 || !tableList[clientOBJ.roomindex] || clientOBJ.sitindex > 5)
	{
		return false;
	}
	var tablestatus = readSOProperty(clientOBJ.roomindex, "tableStatus");
	if (clientOBJ.sitindex > -1)
	{
		/*the user was sit on a sit*/

		var sitobj = readSOProperty(clientOBJ.roomindex, "sit" + clientOBJ.sitindex);
		if (sitobj.playing && sitobj.playing.id == clientOBJ.id)
		{
			if (tablestatus == 2)
			{
				clientOBJ.giveUp();
				/*once give up ,it will change the share object,so pls refresh it*/
				sitobj = readSOProperty(clientOBJ.roomindex, "sit" + clientOBJ.sitindex);
				sitobj.playing = null;
			}
			else
			{
				sitobj.playing = null;
			}
		}
		if (sitobj.waiting && sitobj.waiting.id == clientOBJ.id)
		{
			sitobj.waiting = null;
		}
		writeSOProperty(clientOBJ.roomindex, "sit" + clientOBJ.sitindex, sitobj)
	}
	if (clientOBJ.sitindex == -1)
	{
		var visitorArr = readSOProperty(clientOBJ.roomindex, "visitor");
		var length = visitorArr.length;
		for (var k = 0; k < length; k++)
		{
			if (visitorArr[k].id == clientOBJ.id)
			{
				visitorArr.splice(k, 1);
				break;
			}
		}
		writeSOProperty(clientOBJ.roomindex, "visitor", visitorArr);
	}
	/*check if the game cann't continue or been dead*/
	var livenum = 0;
	if (tablestatus == 2 || tablestatus == 1)
	{
		var timeStamp = readSOProperty(clientOBJ.roomindex, "gameStarttime")
		for (var p = 0; p < 6; p++)
		{
			var sitobj = readSOProperty(clientOBJ.roomindex, "sit" + p);
			if ((sitobj.playing && isAlive(sitobj.playing.id)) || (sitobj.waiting && isAlive(sitobj.waiting.id)))
			{
				livenum++;
			}
		}
		if (livenum == 0 && (getTime() - timeStamp) > 0)
		{
			clientOBJ.cleanPerround(clientOBJ.roomindex, "1adb0262d7491616cec3f998fc8b0c8a");
		}
	}
	return true;
}
/**
 * syncTime 函数，主要用于修正和服务端的时间差。以便精确控制。
 */
Client.prototype.syncTime = function ()
{
	"use strict";
	return getTime();
};

/**
 * requestCharge 函数，客户端在游戏开始时，或者原先的ChargeMan 断线等情况时使用。维护游戏的正常进行。
 */
Client.prototype.requestCharge = function ()
{
	"use strict";
	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex < 0 || this.sitindex > 5)
	{
		return {errID:101, content:"your sitindex is wrong"};
	}
	if (this.roomindex < 0 || !tableList[this.roomindex])
	{
		return {errID:102, content:"your tableIndex is wrong"};
	}
	var chargeSit = -1;
	var sitOBJ = {};
	for (var k = 0; k < this.sitindex; k++)
	{
		sitOBJ = readSOProperty(this.roomindex, "sit" + k)
		if (sitOBJ.playing && isAlive(sitOBJ.playing.id))
		{

			chargeSit = k;
			break;
		}
	}
	if (chargeSit > -1 && chargeSit < 6)
	{
		sitOBJ = readSOProperty(this.roomindex, "sit" + chargeSit);
		chargemanList[this.roomindex] = randRange(1000000, 9999999);
		getClient(sitOBJ.playing.id).call("getsessionid", null, chargemanList[this.roomindex])
	}
	else
	{
		this.call("getsessionid", null, chargemanList[this.roomindex]);
	}

	return null;
};

/**
 * checkPokertype 函数，用于检查传入的参数（数组）的最大牌型。
 */
Client.prototype.checkPokertype = function (publicarr, mypoker)
{
	"use strict";
	//todo
	var whole = [];
	var straightResult = new pokerResult();
	var xkindResult = new pokerResult();
	var xpairResult = new pokerResult();
	var flushResult = new pokerResult();
	var highCard = 0;
	var waitforjudge = 0;

	whole = Clone(publicarr);
	whole.push(mypoker[0]);
	whole.push(mypoker[1]);
	trace("The whole poker length is :" + whole.length);
	whole.sort(ASCsortBynumber);
	trace("start judge")
	/*we check if there's straight series*/
	straightResult = straightCheck(whole);
	if (straightResult != false)
	{
		if (straightResult.pokerType > 7)
		{
			return straightResult;
		}
		waitforjudge = straightResult.pokerType;
	}
	xkindResult = xkindandxPairCheck(whole);
	if (xkindResult != false)
	{
		if (xkindResult.pokerType > 5)
		{
			return xkindResult;
		}
		if (xkindResult.pokerType > waitforjudge)
		{
			return xkindResult;
		}
		/*and now ,we only left 543210 kind*/
	}
	flushResult = flushCheck(whole);
	if (flushResult != false)
	{
		return flushResult;
		/*now ,left 43210*/
	}
	if (waitforjudge > 0)
	{
		return straightResult;
	}
	if (xkindResult != false)
	{
		return xkindResult;
	}

	/*if programe running to here ,the pokerType must be zitCh,high card*/
	trace("you got a high card");
	whole.reverse();
	whole.length = 5;
	whole.reverse();
	return getScore(0, whole);
}


/**
 * straightCheck 函数，用于顺子系列的检查。可以获得，皇家同花顺(9)，同花顺(8)，顺子(4)；
 */
function straightCheck(arrOri)
{
	"use strict";
	arrOri.sort(ASCsortBynumber);
	var result = [];
	var diff = [];
	var any = new pokerResult();
	var arr = [];
	/*firstly ,we should rid of element un-unique*/

	arr = getUnique(arrOri, "number");
	trace("StraightCheck called,ARR length :" + arr.length);
	if (arr.length > 4)
	/*if unique element less than 5,we can sure it's not straight */
	{
		diff = getRemainderone(arr);

		if (diff != false)
		{

			diff.sort(ASCsortBynumber);

////			---debug--
//			var str = "";
//			for (var p =0 ; p < diff.length;p++)
//			{
//				str = str+ "/"+diff[p].number;
//			}
//			trace ("Diff 内容："+str);
////			---debug--

			/*we have got a straight Array,So, continue check if it's flush*/
			any = flushCheck(diff);
			if (any != false)
			{
				result = any.main;
				/*now ,we got Straight Flush,and we continue look for royal*/
				if (result[result.length - 1].number == 14)
				{
					/*OK that is Royal Straight Flush*/
					return  getScore(9, result);
				}
				else
				{
					/*it's just Straight Flush*/
					return  getScore(8, result);
				}
			}
			/*OK,it's just straight*/
			diff.reverse();
			diff.length = 5;
			diff.reverse();
			return   getScore(4, diff);
		}
		return false;
	}
	return false;
}
/**
 * xkindandxPairCheck 函数，用于X条系列的检查。可以获得，四条(7)/三条(3)/三带2(6)/两对(2)/一对(1)；
 */
function xkindandxPairCheck(pokerArr)
{
	"use strict";
	/*we sort arr use number prop from small to bigger*/
	var arr = Clone(pokerArr);
	arr.sort(ASCsortBynumber);
	trace("xkindandXpairCheck called...length is :.." + pokerArr.length);
	/*getSame is an extension function for array*/
	var obj = getSame(arr, "number");
	var result = new pokerResult();
	var same = [];
	var notSame = [];
	var len = arr.length;
	var threearr = [];
	var twoarr = [];
	var oneArr = [];
	var value = 0;
	var threeRest = [];
	var twoRest = [];
	var threepoker = false;
	var pairpoker = false;
	var pairnum = 0;
	var bigPairnum = 0;
	var smallPairnum = 0;
	var bigThreenum = 0;

	for (var prop in obj)
	{
		if (obj[prop]["repeat"] == 4)
		{
			/*haha ,we got four a kind*/
			value = obj[prop]["propValue"]

			for (var index = 0; index < arr.length; index++)
			{

				if (arr[index].number == value)
				{
					same.push(arr[index]);
				}
				else
				{
					notSame.push(arr[index]);
				}
			}

			notSame.sort(ASCsortBynumber);
			notSame.reverse();
			notSame.length = 1;
			return  getScore(7, same, notSame);
		}
		if (obj[prop]["repeat"] == 3)
		{
			/*and now ,Things are a little complicated*/
			threepoker = true;
			(obj[prop]["propValue"] > bigThreenum) ? bigThreenum = obj[prop]["propValue"] : 1 == 1;
			continue;
		}
		if (obj[prop]["repeat"] == 2)
		{
			/*and now ,Things are a little more complicated*/
			pairpoker = true;
			pairnum++;
			if (obj[prop]["propValue"] + 1 > bigPairnum)
			{
				(bigPairnum > smallPairnum) ? smallPairnum = bigPairnum : 1 == 1;
				bigPairnum = obj[prop]["propValue"];
			}
			else
			{
				if (obj[prop]["propValue"] + 1 > smallPairnum)
				{
					smallPairnum = obj[prop]["propValue"];
				}

			}

			continue;
		}

	}

	if (threepoker == true)
	{
		/*now ,we at least have  3 of a kind*/
		if (pairpoker == true)
		{
			/*here is  full house*/
			threearr = [];
			twoarr = [];
			for (var index in arr)
			{
				if (index == "print" || index == "getUnique" || index == "getSame")
				{
					continue;
				}
				if (arr[index].number == bigThreenum)
				{
					threearr.push(arr[index]);
				}
				if (arr[index].number == bigPairnum)
				{
					twoarr.push(arr[index]);
				}
			}
			trace("葫芦，主牌" + threearr.length + " 副牌：" + twoarr.length);
			return  getScore(6, threearr, twoarr);
		}
		else
		{
			/*now ,it's only 3 of a kind*/
			threearr = [];
			threeRest = [];
			for (var index in arr)
			{
				if (index == "print" || index == "getUnique" || index == "getSame")
				{
					continue;
				}
				(arr[index].number == bigThreenum ) ? threearr.push(arr[index]) : threeRest.push(arr[index]);
			}
			threeRest.sort(ASCsortBynumber);
			threeRest.reverse();
			threeRest.length = 2;
			threeRest.reverse();
			trace("三条，主牌" + threearr.length + " 副牌：" + threeRest.length);
			return getScore(3, threearr, threeRest);
		}
	}
	if (pairpoker == true && pairnum > 0 && threepoker == false)
	{
		if (pairnum > 1)
		{
			/*now we got 2 pair pokerType*/
			var mainarr = [];
			var slavearr = [];
			twoRest = [];
			twoRest[0] = new Poker();
			for (var index in arr)
			{
				if (index == "print" || index == "getUnique" || index == "getSame")
				{
					continue;
				}
				(arr[index].number == bigPairnum) ? mainarr.push(arr[index]) : 1 == 1;
				(arr[index].number == smallPairnum) ? slavearr.push(arr[index]) : 1 == 1;
				(arr[index].number > twoRest[0].number) ? twoRest[0] = arr[index] : 1 == 1;
			}
			trace("两对，主牌" + mainarr.length + " 副牌：" + slavearr.length + "次牌 : " + twoRest.length);
			return getScore(2, mainarr, slavearr, twoRest);

		}
		else
		{
			var mainarr = [];
			var slavearr = [];
			for (var index in arr)
			{
				if (index == "print" || index == "getUnique" || index == "getSame")
				{
					continue;
				}
				(arr[index].number == bigPairnum) ? mainarr.push(arr[index]) : slavearr.push(arr[index]);
			}
			slavearr.sort(ASCsortBynumber);
			slavearr.reverse();
			slavearr.length = 3;
			slavearr.reverse();
			trace("一对，主牌" + mainarr.length + " 副牌：" + slavearr.length);
			return getScore(1, mainarr, slavearr);
		}

	}

	return false;
}

/**
 * flushCheck 函数，用于同花的检查。假如同花牌型成功，返回同花(5)数组，否则，返回Fasle；
 */
function flushCheck(arr)
{
	"use strict";
	trace("flushCheck called");
	var fangpianarr = [];
	var heitaoarr = [];
	var hongtaoarr = [];
	var caohuaarr = [];
	for (var k = 0; k < arr.length; k++)
	{
		if (arr[k].type == "caohua")
		{
			caohuaarr.push(arr[k]);
			continue;
		}
		if (arr[k].type == "fangpian")
		{
			fangpianarr.push(arr[k]);
			continue;
		}
		if (arr[k].type == "heitao")
		{
			heitaoarr.push(arr[k]);
			continue;
		}
		if (arr[k].type == "hongtao")
		{
			hongtaoarr.push(arr[k]);
			continue;
		}
	}
	if (caohuaarr.length > 4)
	{
		caohuaarr.sort(ASCsortBynumber);
		caohuaarr.reverse();
		caohuaarr.length = 5;
		caohuaarr.reverse();
		var result = new pokerResult();
		result = getScore(5, caohuaarr);
		return result;
	}
	if (fangpianarr.length > 4)
	{
		fangpianarr.sort(ASCsortBynumber);
		fangpianarr.reverse();
		fangpianarr.length = 5;
		fangpianarr.reverse();
		var result = new pokerResult();
		result = getScore(5, fangpianarr);
		return result;
	}
	if (heitaoarr.length > 4)
	{
		heitaoarr.sort(ASCsortBynumber);
		heitaoarr.reverse();
		heitaoarr.length = 5;
		heitaoarr.reverse();
		var result = new pokerResult();
		result = getScore(5, heitaoarr);
		return result;
	}
	if (hongtaoarr.length > 4)
	{
		hongtaoarr.sort(ASCsortBynumber);
		hongtaoarr.reverse();
		hongtaoarr.length = 5;
		hongtaoarr.reverse();
		var result = new pokerResult();
		result = getScore(5, hongtaoarr);
		return result;
	}
	return false;
}


/**
 * getRemainderone 函数，传入参数为数组，轮询比较与面的元素差值为1的元素
 */
function getRemainderone(arrOri)
{
	"use strict";

	var result = [];
	var straightNum = 0;
	var arr = Clone(arrOri);
	arr.sort(ASCsortBynumber);
	var len = arr.length;
	if (len < 5)
	{
		return false;
	}

	for (var k = 0; k < len; k++)
	{

		if (k < 4)
		{
			if ((arr[k].number - arr[k + 1].number) == -1)
			{
				straightNum++;
				result.push(arr[k]);
			}
			else
			{
				straightNum = 0;
				result = [];

			}
		}
		else
		{
			var preAdd = false;
			/*当K >= 4的时候，要考虑一下 是否和前面一个相差为1 ，如果前面一个差值为1，而且，连续个数已经达到4了，实际上顺子已经成型，只不过没有计算自己而已*/
			if ((arr[k].number - arr[k - 1].number) == 1)
			{
				straightNum++;
				result.push(arr[k]);
				preAdd = true;
			}

			/*上面的代码 先将自己加入result，因为上一次的计算，没有把自己加进result数组*/
			if (arr[k + 1])
			{
				if ((arr[k].number - arr[k + 1].number) == -1)
				{
					if (preAdd == false)
					{
						straightNum++;
						result.push(arr[k]);
					}

				}
				else
				{
					if (straightNum < 5)
					{
						straightNum = 0;
						result = [];
					}
					else
					{
						return result;
					}
				}

			}
			else
			{
				/*如果K+1已经没有了，说明到头了，只能看看到自己这里，是否能组成5张连续*/
				if (straightNum < 5)
				{
					straightNum = 0;
					result = [];
					return false;
				}
				else
				{
					return result;
				}
			}
		}
	}

	trace("获得差值数组长度： " + result.length)
	return false;
}

/**
 * getScore 函数，算分并返回pokerResult 类型的对象。应该在牌型最终确定后 才调用此函数
 */
function getScore(pokerType, mainArr, slaveArr, optionArr)
{
	"use strict";
	if (!mainArr)
	{
		return false
	}
	;
	if ((pokerType == 7 || pokerType == 6 || pokerType == 3 || pokerType == 1) && !slaveArr)
	{
		return false
	}
	;
	if (pokerType == 2 && (!slaveArr || !optionArr))
	{
		return false;
	}
//	trace("getscore called ,pokerType is :" + pokerType + " mainlength: " + mainArr.length);
	var score = new pokerResult();
	mainArr.sort(ASCsortBynumber);
	var len = mainArr.length;

	score.pokerType = pokerType;
	score.main = commitArr(mainArr);


	if (pokerType == 9 || pokerType == 8 || pokerType == 4 || pokerType == 5 || pokerType == 0)
	{
		/*mainArr is obsoluly exists*/
		score.pokerScore = score.pokerType * 100000000 + mainArr[len - 1].number * 1000000 + mainArr[len - 2].number * 10000 + mainArr[len - 3].number * 100 + mainArr[len - 4].number + mainArr[len - 5].number * 0.01;
		trace("Poker Score: " + score.pokerScore + "  PokerType : " + score.pokerType);
		return score;
	}
	if (pokerType == 7 || pokerType == 6)
	{
		/*we have checed if slave arr is exists*/
		slaveArr.sort(ASCsortBynumber);
		var slavelen = slaveArr.length;
		score.slave = commitArr(slaveArr);
		score.pokerScore = score.pokerType * 100000000 + mainArr[len - 1].number * 1000000 + slaveArr[slavelen - 1].number * 10000;
		trace("Poker Score: " + score.pokerScore + "  PokerType : " + score.pokerType);
		return score;
	}
	if (pokerType == 3)
	{
		/*we have checed if slave arr is exists*/
		slaveArr.sort(ASCsortBynumber);
		var slavelen = slaveArr.length;
		score.slave = commitArr(slaveArr);
		score.pokerScore = score.pokerType * 100000000 + mainArr[len - 1].number * 1000000 + slaveArr[slavelen - 1].number * 10000 + slaveArr[slavelen - 2].number * 100;
		trace("Poker Score: " + score.pokerScore + "  PokerType : " + score.pokerType);
		return score;
	}
	if (pokerType == 1)
	{
		/*we have checed if slave arr is exists*/
		slaveArr.sort(ASCsortBynumber);
		var slavelen = slaveArr.length;
		score.slave = commitArr(slaveArr);
		score.pokerScore = score.pokerType * 100000000 + mainArr[len - 1].number * 1000000 + slaveArr[slavelen - 1].number * 10000 + slaveArr[slavelen - 2].number * 100 + slaveArr[slavelen - 3].number;
		trace("Poker Score: " + score.pokerScore + "  PokerType : " + score.pokerType);
		return score;
	}
	if (pokerType == 2)
	{
		/*we have checed if slave arr && optionArr is exists*/
		slaveArr.sort(ASCsortBynumber);
		var slavelen = slaveArr.length;
		score.slave = commitArr(slaveArr);

		optionArr.sort(ASCsortBynumber);
		var optionlen = optionArr.length;
		score.third = commitArr(optionArr);
		score.pokerScore = score.pokerType * 100000000 + mainArr[len - 1].number * 1000000 + slaveArr[slavelen - 1].number * 10000 + optionArr[optionlen - 1].number * 100;
		trace("Poker Score: " + score.pokerScore + "  PokerType : " + score.pokerType);
		return  score;
	}
	//
	trace("there's error in ur program")
	return false;
}


//升序排列函数
function ASCsortBynumber(objA, objB)
{
	if (objA.number < objB.number)
	{
		return -1;
	}
	if (objA.number > objB.number)
	{
		return 1;
	}
	return 0;
}
/**
 * ASCsortByScoreAndsitTotalbet 排序函数。首先对数组中的pokerScore字段进行升序排列。
 * 如果pokerScore值相等，那么以 sitTotalbet 降序排列。也就是说 ，如果牌面相同，下注小的
 * 会排在数组后面。
 */
function ASCsortByScoreAndsitTotalbet(objA, objB)
{
	if (objA.pokerResult.pokerScore < objB.pokerResult.pokerScore)
	{
		return -1;
	}
	if (objA.pokerResult.pokerScore > objB.pokerResult.pokerScore)
	{
		return 1;
	}
	if (objA.pokerResult.pokerScore == objB.pokerResult.pokerScore)
	{
		if (objA.sitTotalbet > objB.sitTotalbet)
		{
			return -1;
		}
		if (objA.sitTotalbet < objB.sitTotalbet)
		{
			return 1;
		}
	}
	return 0;
}


/**
 * cleanPerround函数，每局游戏结束之后，调用的清理函数
 *
 */
Client.prototype.cleanPerround = function (tableID, key)
{
	if (key != "1adb0262d7491616cec3f998fc8b0c8a")
	{
		return {errID:103, content:"MD5 Password not correct"};
	}
	/*Normally check ,if the  client roomIndex and SitIndex is illegal*/
	if (this.sitindex > 5)
	{
		this.sitindex = -1;
		return {errID:101, content:"your sitindex is wrong,we have reset it"};
	}


	writeSOProperty(tableID, "tableStatus", 0);
	writeSOProperty(tableID, "gameStarttime", -1);
	writeSOProperty(tableID, "publicPoker", []);
	writeSOProperty(tableID, "roundStatus", -1);
//	writeSOProperty(tableID, "pokerTemplate", washPoker());
	tableList[this.roomindex].pokerTemplate = washPoker();
	writeSOProperty(tableID, "tableTotalbet", 0);
	writeSOProperty(tableID, "tableUsers", 0);

	/*call the refresh function of SitClass,Clean sit*/
	for (var k = 0; k < 6; k++)
	{
		var sitclass = readSOProperty(tableID, "sit" + k);
		sitclass.refresh();
		if (!sitclass.playing || !isAlive(sitclass.playing.id))
		{
			sitclass.playing = null;

		}
		if (sitclass.playing != null)
		{
			sitclass.playing = getClient(sitclass.playing.id);

			if (sitclass.playing.currentbalance < (tableList[this.roomindex].bigBlind / 2))
			{
				sitclass.waiting = sitclass.playing;
				sitclass.playing = null;
			}
		}

		writeSOProperty(tableID, "sit" + k, sitclass);
	}
	return {errID:1, content:tableID};
	;
}

function randRange(min, max)
{
	return  (Math.floor(Math.random() * (max - min + 1)) + min);
}


/**
 * 对传输的 数组元素进行 加工处理
 * */
function transferTablelist(arr)
{
	"use strict";
	var temparr = [];
	temparr = Clone(arr);
	temparr.forEach(delObjprop)
	return temparr;
}

function delObjprop(element, index, array)
{
	"use strict";
	element.password = "cann't transfer to u"
}
/**
 * 初始化一个 具有一部分 Table对象属性的 ShareObject 。本函数是为了简化代码而制作。
 */
function creatTableso(tableobj)
{
	"use strict";
	var so = SharedObject.get(tableobj.id + "", true);
	so.clear();
	for (var prop in tableobj)
	{
//		trace ("PropName is  :"+ prop + "  and tableobj[prop] = "+tableobj[prop]);
		if (prop != "password")
		{
			so.setProperty(prop, tableobj[prop]);
		}
	}
	for (var s = 0; s < 6; s++)
	{
		var sitobj = new sitClass();
		so.setProperty("sit" + s, sitobj);
	}
	/*Setting the Prop,include (桌子状态，洗好的牌，游戏开始时间，公共牌数组，旁观者数组)*/
	so.setProperty("tableStatus", 0);
//	so.setProperty("pokerTemplate", washPoker());
	so.setProperty("gameStarttime", -1);
	so.setProperty("publicPoker", []);
	so.setProperty("roundStatus", -1);
	so.setProperty("visitor", []);
	so.setProperty("tableTotalbet", 0);
	so.setProperty("tableUsers", 0);
	SharedObject.commit(tableobj + "".id);
	return so;
}

/**
 * 封装时间函数。简化代码
 * */
function getTime()
{
	"use strict";
	var g_Date = new Date();
	return g_Date.getTime();
}

/**
 * 复制对象，在使用AS3 的ByteArray 对象之后，此函数可靠性增加。可正常使用。
 * */

function Clone(obj)
{
	var objClone = new ByteArray();
	objClone.writeObject(obj);
	objClone.position = 0;
	return objClone.readObject();
}

/**
 * 洗牌函数
 *
 */
function washPoker()
{
	"use strict";
	var washed = pokerTemplates.slice();
	for (var x = 0; x < 52; x++)
	{
		washed.sort(function ()
		{
			return Math.random() > 0.5 ? -1 : 1;
		});//洗牌
	}

	return washed;
}

/**
 * ShareObject 读取操作函数,免除每次重复写代码之苦
 *
 */
function readSOProperty(soindex, propertyName)
{
	return g_tableSOArr[soindex].getProperty(propertyName);

}
/**
 * ShareObject 写入并更新操作函数,免除每次重复写代码之苦
 *
 */
function writeSOProperty(soindex, propertyName, Value)
{

	return  g_tableSOArr[soindex].setProperty(propertyName, Value);
}
/**
 * g_SOWrite 函数，用于绕过Client 的SO限制。
 */
function g_SOWrite(soOBJ, propertyName, Value)
{
	"use strict";
	return soOBJ.setProperty(propertyName, Value);
}

/**
 * 数组扩展函数，可针对对象的某个属性，进行唯一性筛选
 */
function getUnique(arr, propName)
{
	var a = {}, c = [], l = arr.length;
	for (var i = 0; i < l; i++)
	{
		var b = arr[i][propName];
		var d = (typeof b) + b;
		if (a[d] === undefined)
		{
			c.push(arr[i]);
			a[d] = 1;
		}
	}
	return c;
}

/**
 * 数组扩展函数，筛选数组元素（对象）指定属性的值相同的个数
 */
function getSame(arr, propName)
{

	var a = {}, c = [], l = arr.length, same = {}, sameTime = 1, sameTotal = [];
	for (var i = 0; i < l; i++)
	{
		var b = arr[i][propName];
		var d = (typeof b) + b;
		if (a[d] === undefined)
		{
			a[d] = 1;
			same[d] = {propValue:b, repeat:a[d]};
		}
		else
		{
			a[d] += 1;
			same[d] = {propValue:b, repeat:a[d]};
		}

	}
	return same;
}
/**
 * checkSmallestsit  函数。检查是否是当前座位号最小的用户。
 */
function checkSmallestsit(clientOBJ)
{
	"use strict";
	var sitobj = new sitClass();
	var tableID = clientOBJ.roomindex;
	for (var k = 0; k < 6; k++)
	{
		sitobj = readSOProperty(tableID, "sit" + k)
		if (sitobj.playing && isAlive(sitobj.playing.id))
		{
			if (sitobj.playing.id == clientOBJ.id)
			{
				return  true;
			}
			else
			{
				return false;
			}

		}
	}
}
/**
 * isAlive函数 ，判断用户是否真正存活；
 */
function isAlive(userID)
{
	"use strict";
	var len = application.clients.length;
	var user = {}
	for (var k = 0; k < len; k++)
	{
		if (application.clients[k].id = userID)
		{
			user = application.clients[k];
			break;
		}
	}
	if (user.id)
	{
		return user.ping();
	}

	return false;

}

/**
 * getClient 函数 ，判断用户是否真正存活；
 */
function getClient(userID)
{
	"use strict";
	var len = application.clients.length;
	var user = {}
	for (var k = 0; k < len; k++)
	{
		if (application.clients[k].id == userID)
		{
			user = application.clients[k];
			return user;
		}
	}
	return null;

}


function printArr(arr)
{
	"use strict";
	for (var k = 0; k < arr.length; k++)
	{
		if (arr[k])
		{
			trace("Array[" + k + "]: " + "\n");
			for (var prop in arr[k])
			{
				trace(prop + " :" + arr[k][prop] + "  ");
			}
		}
	}
}

/**
 * commitArr 函数，去除数组里面的空元素。返回新的数组
 */

function commitArr(arr)
{
	var len = arr.length;
	var newArr = [];
	for (var k = 0; k < len; k++)
	{
		if (arr[k] != undefined)
		{
			newArr.push(arr[k]);
		}
	}
	return newArr;
}

